# 조인순서
1. ORDERED 힌트
- ORDERED 힌트를 이용하여 조인 순서를 조절함으로써, 조인 건수가 적거나 초기에 범위를 줄여주는 테이블을 먼저 조인하도록 한다.
```sql
SELECT /*+ ORDERED */ A.DEPTNM,B.USERNM,C.MENUID
FROM   CRDPTCDT A,CRUSERIT B,CRUSRAUT C
WHERE  A.PDDEPTCD=B.PDDEPTCD
AND    B.USERID=C.USERID;
```
(주의) ORDERED 힌트를 사용하면 FROM절에서 가장 가까운 테이블로부터 조인된다.

2. STAR 힌트
```sql
테이블명 : 인덱스명 : 컬럼구성
------------------------------------
CRUSERIT : CRUSERIT_PK : USERID
CRPROGIT : CRPROGIT_PK : MENUID
CRUSRAUT : CRUSRAUT_PK : USERID + MENUID + USERAUTH

SELECT A.USERID,A.USERNM,
       B.MENUID,B.PGMNM,
       C.USERAUTH,C.AUTHDTC
FROM   CRUSERIT A, CRPROGIT B, CRUSRAUT C
WHERE  A.USERID = C.USERID
AND    B.MENUID = C.MENUID
AND    A.USERID = '1111111111111'
AND    B.UPMENUID LIKE 'B1010%';
```
(주의) 조인순서는 CRUSERIT --> CRUSRAUT --> CRPROGIT이다. 여기에서 CRUSERIT 와 CRPROGIT이 먼저 조인을 일으키도록 아래와 같이 STAR 힌트를 사용할 수 있다.
```sql
SELECT /*+ STAR(A B) */
       A.USERID,A.USERNM,
       B.MENUID,B.PGMNM,
       C.USERAUTH,C.AUTHDTC
FROM   CRUSERIT A, CRPROGIT B, CRUSRAUT C
WHERE  A.USERID = C.USERID
AND    B.MENUID = C.MENUID
AND    A.USERID = '1111111111111'
AND    B.UPMENUID LIKE 'B1010%';
```
(주의) STAR 힌트에 의해 CRUSERIT --> CRPROGIT --> CRUSRAUT의 순서로 조인된다. CRUSERID와 CRPROGIT은 카테션 곱을 일으키지만 그 건수가 작고 CRUSRAUT 테이블이 인덱스를 USERID+MENUID까지 EQUAL로 액세스할 수 있기 때문에 STAR 조인이 유리하다. CRUSRAUT 테이블의 건수가 아주 많은 반면 CRUSERIT,CRPROGIT 테이블의 건수가 적은 경우에 많이 사용되는 조인이다.
# 조인방법
1. NESTED LOOPS 조인 (USE_NL 힌트)
- /* NESTED LOOP JOIN(1)  SMALL TABLE --> BIG TABLE */
```sql
SELECT /*+ USE_NL(B A) */
       COUNT(DISTINCT B.COMPNM) AS NUMCOMP,
       SUM(A.CONTAMT) AS SUMCONT,
       SUM(A.DOGAMT)  AS SUMDOG
FROM   CRL3000T A, CRLR001T B
WHERE  A.COMPCD = B.COMPCD;
```
- /* NESTED LOOP JOIN(2)  BIG TABLE --> SMALL TABLE */
```sql
SELECT /*+ USE_NL(A B) */
       COUNT(DISTINCT B.COMPNM) AS NUMCOMP,
       SUM(A.CONTAMT) AS SUMCONT,
       SUM(A.DOGAMT)  AS SUMDOG
FROM   CRLR001T B, CRL3000T A
WHERE  A.COMPCD = B.COMPCD;
```

2. SORT MERGE 조인 (USE_MERGE 힌트)
```sql
SELECT /*+ USE_MERGE(A B) */
       COUNT(DISTINCT B.COMPNM) AS NUMCOMP,
       SUM(A.CONTAMT) AS SUMCONT,
       SUM(A.DOGAMT)  AS SUMDOG
FROM   CRL3000T A, CRLR001T B
WHERE  A.COMPCD = B.COMPCD;
```

3. HASH 조인 (USE_HASH 힌트)
```sql
SELECT /*+ USE_HASH(A B) */
       COUNT(DISTINCT B.COMPNM) AS NUMCOMP,
       SUM(A.CONTAMT) AS SUMCONT,
       SUM(A.DOGAMT)  AS SUMDOG
FROM   CRL3000T A, CRLR001T B
WHERE  A.COMPCD = B.COMPCD;
```

4. 인라인뷰를 이용한 조인
- 조인 결과에 대해 SUM()을 수행하는 것보다 미리 SUM()을 수행한 인라인뷰와 조인하면 조인 회수를 줄일 수 있다.
```sql
SELECT COUNT(DISTINCT B.COMPNM) AS NUMCOMP,
       SUM(V.SUMCONT)  AS SUMCONT,
       SUM(V.SUMDOG)   AS SUMDOG
FROM   (SELECT A.COMPCD,
               SUM(A.CONTAMT) AS SUMCONT,
               SUM(A.DOGAMT)  AS SUMDOG
        FROM   CRL3000T A
        GROUP BY A.COMPCD) V,
       CRLR001T B
WHERE  V.COMPCD = B.COMPCD;
```

# 서브쿼리
1. 조인을 피하기 위한 서브쿼리
> 조인하는 경우
```sql
SELECT C.ACCNAME,
       SUM(TOTAL12) TOTAL12,SUM(VIEW12) VIEW12,SUM(MONTH12) MONTH12
FROM   CKSSCHET A, CYHPS01T B, CKSACCT C
WHERE  A.ITEM = 'A'
AND    A.YEAR = '1998'
AND    (A.ACCCODE = 'B01' OR A.ACCCODE BETWEEN 'G01' AND 'P0102')
AND    A.SITE = B.SITE
AND    B.PHASE = '00'
AND    B.AREA_CLASS LIKE '1%'
AND    A.ACCCODE = C.ACCCODE
GROUP BY C.ACCNAME;
```
- (주의) CKSSCHET와 CYHPS01T가 조인하는 것은 단순히 PHASE와 AREA_CLASS 컬럼에 대해 체크기능을 수행하기 위한 것으로 실제로는 SELECT될 필요가 없는 조인이다. 따라서 아래와 같이 EXISTS 서브쿼리를 이용하여 체크기능을 수행하면 더 빠르게 수행된다.
> EXISTS 서브쿼리를 사용하는 경우
```sql
SELECT C.ACCNAME,V.TOTAL12,V.VIEW12,V.MONTH12
FROM   (SELECT A.ACCCODE,
               SUM(TOTAL12) TOTAL12,SUM(VIEW12) VIEW12,SUM(MONTH12) MONTH12
        FROM   CKSSCHET A
        WHERE  A.ITEM = 'A'
        AND    A.YEAR = '1998'
        AND    (A.ACCCODE = 'B01' OR A.ACCCODE BETWEEN 'G01' AND 'P0102')
        AND    EXISTS (SELECT 'X' FROM CYHPS01T B
                       WHERE  A.SITE = B.SITE
                       AND    B.PHASE = '00'
                       AND    B.AREA_CLASS LIKE '1%')
        GROUP BY A.ACCCODE) V, CKSACCT C
WHERE  V.ACCCODE = C.ACCCODE;
```
- (주의) CKSSCHET와 CKSACCT가 조인하는 것은 단순히 ACCNAME(계정명)을 가져오기 위한 것이므로 인라인뷰에서 미리 SUM을 구한 후 조인함으로써 조인 회수를 줄일 수 있다.
2. 순서 조정 (PUSH_SUBQ 힌트)
- 서브쿼리를 먼저 풀리게 하여 초기에 건수를 줄임으로써 나중에 발생되는 조인회수를 줄인다.
```sql
SELECT /*+ PUSH_SUBQ */
       A.MENUID,A.AWSGB,
       DECODE(A.AWSGB,'1',B.USERNM) AS USERNM,
       DECODE(A.AWSGB,'2',C.DEPTNM) AS DEPTNM,
       DECODE(A.AWSGB,'3',A.AWSMAN) AS AWSMAN
FROM   CRPROGIT A, CRUSERIT B, CRDPTCDT C
WHERE  A.AWSMAN = B.USERID(+)
AND    A.AWSMAN = C.PDDEPTCD(+)
AND    EXISTS (SELECT 'X' FROM CRLOGINT C
               WHERE  A.MENUID = C.MENUID);
```
3. NOT IN 서브쿼리 (HASH_AJ,MERGE_AJ 힌트)
```sql
SELECT COMPCD,COMPNM
FROM   CRLR001T A
WHERE  COMPCD NOT IN (SELECT COMPCD
                      FROM   CRL3000T B
                      WHERE  CONTDTC BETWEEN '19970101' AND '19971231')
```
- (주의) 플랜이 FILTER로서 풀리며 CRL3000T 테이블을 매번 FULL SCAN하므로 실행 시간이 많이 소요된다. 이때에는 아래와 같이 HASH_AJ 힌트를 이용하여 ANTI-JOIN으로 풀리게 함으로써 실행시간을 단축시킬 수 있다.
```sql
SELECT COMPCD,COMPNM
FROM   CRLR001T A
WHERE  COMPCD NOT IN (SELECT /*+ HASH_AJ*/
                             COMPCD
                      FROM   CRL3000T B
                      WHERE  COMPCD IS NOT NULL
                      AND    CONTDTC BETWEEN '19970101' AND '19971231')
```
- (주의) HASH_AJ 힌트를 사용하더라도 COMPCD IS NOT NULL 조건이 없다면 ANTI-JOIN으로 풀리지 않으므로 반드시 이 조건을 삽입하여야 한다. CRL3000T 테이블이 매우 큰 테이블이고 시스템 자원이 충분하다면 아래와 같이 FULL힌트와 PARALLEL 힌트를 이용하여 더욱 빠르게 실행할 수 있다.
```sql
SELECT COMPCD,COMPNM
FROM   CRLR001T A
WHERE  COMPCD NOT IN (SELECT /*+ HASH_AJ FULL(B) PARALLEL(B 4)*/
                             COMPCD
                      FROM   CRL3000T B
                      WHERE  COMPCD IS NOT NULL
                      AND    CONTDTC BETWEEN '19970101' AND '19971231')

SELECT COMPCD,COMPNM
FROM   CRLR001T A
WHERE  COMPCD NOT IN (SELECT /*+ MERGE_AJ*/
                             COMPCD
                      FROM   CRL3000T B
                      WHERE  COMPCD IS NOT NULL
                      AND    CONTDTC BETWEEN '19970101' AND '19971231')
```
- (주의) HASH_AJ 대신에 MERGE_AJ 힌트를 사용할 수도 있다. 이때에는 ANTI-JOIN이 해쉬가 아닌 머지로 풀리게 된다. 그러나 MERGE_AJ힌트보다는 HASH_AJ 힌트를 더 권장한다.

# OUTER-JOIN
```sql
-- CRUSERIT를 드라이빙 테이블로 하여 CRUSRAUT,CRPROGIT와 차례로 OUTER-JOIN한다. 
-- 조인 순서 : CRUSERIT --> CRUSRAUT --> CRPROGIT

SELECT C.USERID,C.USERNM,A.MENUID,B.PGMNM,
       MIN(DECODE(A.USERAUTH,'I','O','X')) AS 입력,
       MIN(DECODE(A.USERAUTH,'U','O','X')) AS 변경,
       MIN(DECODE(A.USERAUTH,'S','O','X')) AS 조회,
       MIN(DECODE(A.USERAUTH,'R','O','X')) AS 정의
FROM   CRUSRAUT A, CRPROGIT B, CRUSERIT C
WHERE  A.MENUID = B.MENUID(+)
AND    A.USERID(+) = C.USERID
AND    C.PDDEPTCD = 'B10CA97140'
GROUP BY C.USERID,C.USERNM,A.MENUID,B.PGMNM;
```
- (주의) CRUSRAUT에서 CRPROGIT의 관계가 MANDATORY일지라도 OUTER-JOIN해야 한다.
```sql
-- CRUSRAUT 테이블의 AUTHDTC에 대한 조건을 추가한다.
SELECT C.USERID,C.USERNM,A.MENUID,B.PGMNM,
       MIN(DECODE(A.USERAUTH,'I','O','X')) AS 입력,
       MIN(DECODE(A.USERAUTH,'U','O','X')) AS 변경,
       MIN(DECODE(A.USERAUTH,'S','O','X')) AS 조회
FROM   CRUSRAUT A, CRPROGIT B, CRUSERIT C
WHERE  A.MENUID = B.MENUID(+)
AND    A.AUTHDTC(+) BETWEEN '19970101' AND '19971231'
AND    A.USERID(+) = C.USERID
AND    C.PDDEPTCD = 'B10CA97140'
GROUP BY C.USERID,C.USERNM,A.MENUID,B.PGMNM;
```
- (주의) OUTER-JOIN되는 CRUSRAUT 테이블의 컬럼에는 (+) 기호를 붙인다.
```sql
-- OUTER-JOIN되는 테이블의 컬럼이 OR 또는 IN으로 비교될 때에는 OUTER-JOIN의 특성상 컬럼에 (+)를 불일 수 없다. 
-- 이러한 경우 컬럼값의 특성을 이용하여 IN 조건을 != 조건으로 변환한다.
SELECT C.USERID,C.USERNM,A.MENUID,B.PGMNM,
       MIN(DECODE(A.USERAUTH,'I','O','X')) AS 입력,
       MIN(DECODE(A.USERAUTH,'U','O','X')) AS 변경,
       MIN(DECODE(A.USERAUTH,'S','O','X')) AS 조회
FROM   CRUSRAUT A, CRPROGIT B, CRUSERIT C
WHERE  A.MENUID = B.MENUID(+)
AND    A.USERAUTH(+) != 'R'  /* USERAUTH는 R,I,U,S 중에서 하나의 값을 가짐 */
--AND  A.USERAUTH(+) IN ('I','U','S') /* IN 은 OUTER-JOIN 사용 불가 */
AND    A.AUTHDTC(+) BETWEEN '19970101' AND '19971231'
AND    A.USERID(+) = C.USERID
AND    C.PDDEPTCD = 'B10CA97140'
GROUP BY C.USERID,C.USERNM,A.MENUID,B.PGMNM;
```
```sql
-- OUTER-JOIN에서 OR 또는 IN에 대한 해결책으로 IN-LINE VIEW를 사용할 수도 있다.

SELECT C.USERID,C.USERNM,A.MENUID,B.PGMNM,
       MIN(DECODE(A.USERAUTH,'I','O','X')) AS 입력,
       MIN(DECODE(A.USERAUTH,'U','O','X')) AS 변경,
       MIN(DECODE(A.USERAUTH,'S','O','X')) AS 조회
FROM   (SELECT USERID,MENUID,USERAUTH
        FROM   CRUSRAUT
        WHERE  USERAUTH IN ('I','U','S')
        AND    AUTHDTC BETWEEN '19970101' AND '19971231') A,
       CRPROGIT B, CRUSERIT C
WHERE  A.MENUID = B.MENUID(+)
AND    A.USERID(+) = C.USERID
AND    C.PDDEPTCD = 'B10CA97140'
GROUP BY C.USERID,C.USERNM,A.MENUID,B.PGMNM; 
```